Sub ProcessInsuranceData()
    Dim ws As Worksheet
    Set ws = ActiveSheet ' Change to specific sheet if needed, e.g., ThisWorkbook.Sheets("Sheet1")
    
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, 10).End(xlUp).Row ' Column J for last row detection
    If lastRow < 2 Then Exit Sub
    
    ' Constants for columns
    Const colEff As Long = 10 ' J
    Const colExp As Long = 11 ' K
    Const colDirect As Long = 15 ' O
    Const colDereg As Long = 16 ' P
    Const colIss As Long = 17 ' Q
    Const colDom As Long = 18 ' R
    Const colCov As Long = 19 ' S
    Const colSec As Long = 20 ' T
    Const colClaim As Long = 21 ' U
    Const colCommonDate As Long = 24 ' X
    Const colCommonIss As Long = 25 ' Y
    Const colCommonDom As Long = 26 ' Z
    Const colTC As Long = 1 ' A
    
    Const earlyDate As Date = #1/1/1900#
    Const lateDate As Date = #12/31/9999#
    
    ' Load data into arrays
    Dim effDates() As Date, expDates() As Date
    Dim directs() As String, deregs() As String, iss() As String, doms() As String
    Dim covs() As String, secs() As String, claims() As String
    ReDim effDates(2 To lastRow), expDates(2 To lastRow)
    ReDim directs(2 To lastRow), deregs(2 To lastRow), iss(2 To lastRow), doms(2 To lastRow)
    ReDim covs(2 To lastRow), secs(2 To lastRow), claims(2 To lastRow)
    
    Dim i As Long
    For i = 2 To lastRow
        If IsDate(ws.Cells(i, colEff).Value) Then
            effDates(i) = ws.Cells(i, colEff).Value
        Else
            effDates(i) = earlyDate
        End If
        If IsDate(ws.Cells(i, colExp).Value) Then
            expDates(i) = ws.Cells(i, colExp).Value
        Else
            expDates(i) = lateDate
        End If
        directs(i) = Trim(ws.Cells(i, colDirect).Value)
        deregs(i) = UCase(Trim(ws.Cells(i, colDereg).Value))
        iss(i) = Trim(ws.Cells(i, colIss).Value)
        doms(i) = Trim(ws.Cells(i, colDom).Value)
        covs(i) = Trim(ws.Cells(i, colCov).Value)
        secs(i) = Trim(ws.Cells(i, colSec).Value)
        claims(i) = Trim(ws.Cells(i, colClaim).Value)
    Next i
    
    ' Union-Find setup
    Dim parent() As Long
    ReDim parent(2 To lastRow)
    For i = 2 To lastRow
        parent(i) = i
    Next i
    
    ' Find function
    Dim Find As Variant ' Lambda-like via Application.Run, but use recursive
    ' Simple recursive Find
    ' Note: For large N, risk stack overflow, but assuming small lastRow
    
    ' Union
    For i = 2 To lastRow - 1
        For j = i + 1 To lastRow
            Dim maxEff As Date: maxEff = IIf(effDates(i) > effDates(j), effDates(i), effDates(j))
            Dim minExp As Date: minExp = IIf(expDates(i) < expDates(j), expDates(i), expDates(j))
            If maxEff <= minExp Then
                If directs(i) = directs(j) And covs(i) = covs(j) And secs(i) = secs(j) And claims(i) = claims(j) Then
                    If deregs(i) = deregs(j) Or deregs(i) = "BOTH" Or deregs(j) = "BOTH" Then
                        ' Union
                        Dim r1 As Long: r1 = i
                        While parent(r1) <> r1
                            r1 = parent(r1)
                        Wend
                        Dim r2 As Long: r2 = j
                        While parent(r2) <> r2
                            r2 = parent(r2)
                        Wend
                        If r1 <> r2 Then parent(r1) = r2
                    End If
                End If
            End If
        Next j
    Next i
    
    ' Path compression and collect groups
    Dim groups As Object
    Set groups = CreateObject("Scripting.Dictionary")
    For i = 2 To lastRow
        Dim root As Long: root = i
        While parent(root) <> root
            root = parent(root)
        Wend
        ' Compress
        Dim p As Long: p = i
        While parent(p) <> root
            Dim nextP As Long: nextP = parent(p)
            parent(p) = root
            p = nextP
        Wend
        If Not groups.Exists(root) Then
            Set groups(root) = New Collection
        End If
        groups(root).Add i
    Next i
    
    ' Group list
    Dim groupList As New Collection
    For Each key In groups.Keys
        groupList.Add groups(key)
    Next
    
    ' Sort groups by min row number
    Dim swapped As Boolean
    Do
        swapped = False
        For i = 1 To groupList.Count - 1
            Dim g1 As Collection: Set g1 = groupList(i)
            Dim g2 As Collection: Set g2 = groupList(i + 1)
            Dim min1 As Long: min1 = Application.Min(g1)
            Dim min2 As Long: min2 = Application.Min(g2)
            If min1 > min2 Then
                Dim temp As Collection
                Set temp = groupList(i)
                Set groupList(i) = groupList(i + 1)
                Set groupList(i + 1) = temp
                swapped = True
            End If
        Next i
    Loop While swapped
    
    ' Sort within each group by row number
    For Each g In groupList
        Do
            swapped = False
            For i = 1 To g.Count - 1
                If g(i) > g(i + 1) Then
                    Dim tmp As Long: tmp = g(i)
                    g(i) = g(i + 1)
                    g(i + 1) = tmp
                    swapped = True
                End If
            Next i
        Loop While swapped
    Next
    
    ' Prepare new data array (copy entire rows)
    Dim maxCol As Long: maxCol = ws.UsedRange.Columns.Count
    Dim newData() As Variant
    ReDim newData(1 To lastRow - 1, 1 To maxCol)
    
    Dim newIdx As Long: newIdx = 1
    For Each g In groupList
        For Each oldRow In g
            For Dim c As Long = 1 To maxCol
                newData(newIdx, c) = ws.Cells(oldRow, c).Value
            Next c
            newIdx = newIdx + 1
        Next
    Next
    
    ' Clear old data
    ws.Rows("2:" & lastRow).ClearContents ' Clear contents only, keep formats if any
    
    ' Paste new data
    ws.Range(ws.Cells(2, 1), ws.Cells(lastRow, maxCol)).Value = newData
    
    ' Now process groups for commons, TC, and merging
    Application.DisplayAlerts = False
    Dim currRow As Long: currRow = 2
    For Each g In groupList
        Dim gSize As Long: gSize = g.Count
        ' Calculate common date (overlap start = max eff)
        Dim maxEff As Date: maxEff = earlyDate
        Dim hasEff As Boolean: hasEff = False
        For Each oldRow In g
            If effDates(oldRow) <> earlyDate Then
                If effDates(oldRow) > maxEff Then maxEff = effDates(oldRow)
                hasEff = True
            End If
        Next
        Dim commonDate As Variant
        If Not hasEff Then
            commonDate = ""
        Else
            commonDate = maxEff
        End If
        
        ' Common issuing (unique, comma separated)
        Dim issDict As Object: Set issDict = CreateObject("Scripting.Dictionary")
        For Each oldRow In g
            If iss(oldRow) <> "" Then issDict(iss(oldRow)) = 1
        Next
        Dim commonIss As String: commonIss = Join(issDict.Keys, ",")
        
        ' Common domicile
        Dim domDict As Object: Set domDict = CreateObject("Scripting.Dictionary")
        For Each oldRow In g
            If doms(oldRow) <> "" Then domDict(doms(oldRow)) = 1
        Next
        Dim commonDom As String: commonDom = Join(domDict.Keys, ",")
        
        ' Fill for group rows
        Dim groupStart As Long: groupStart = currRow
        Dim groupEnd As Long: groupEnd = currRow + gSize - 1
        Dim n As Long: n = 1
        For i = groupStart To groupEnd
            ws.Cells(i, colTC).Value = "TC_" & n
            ws.Cells(i, colCommonDate).Value = commonDate
            ws.Cells(i, colCommonIss).Value = commonIss
            ws.Cells(i, colCommonDom).Value = commonDom
            n = n + 1
        Next i
        
        ' Merge cells in X, Y, Z if group >1
        If gSize > 1 Then
            ws.Range(ws.Cells(groupStart, colCommonDate), ws.Cells(groupEnd, colCommonDate)).Merge
            ws.Range(ws.Cells(groupStart, colCommonIss), ws.Cells(groupEnd, colCommonIss)).Merge
            ws.Range(ws.Cells(groupStart, colCommonDom), ws.Cells(groupEnd, colCommonDom)).Merge
        End If
        
        currRow = currRow + gSize
    Next
    Application.DisplayAlerts = True
End Sub

Sub ProcessInsuranceData()
    Dim ws As Worksheet
    Set ws = ActiveSheet ' Change to specific sheet if needed, e.g., ThisWorkbook.Sheets("Sheet1")
    
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, 10).End(xlUp).Row ' Column J for last row detection
    If lastRow < 2 Then Exit Sub
    
    ' Constants for columns
    Const colEff As Long = 10    ' J
    Const colExp As Long = 11    ' K
    Const colDirect As Long = 15 ' O
    Const colDereg As Long = 16  ' P
    Const colIss As Long = 17    ' Q
    Const colDom As Long = 18    ' R
    Const colCov As Long = 19    ' S
    Const colSec As Long = 20    ' T
    Const colClaim As Long = 21  ' U
    Const colCommonDate As Long = 24 ' X
    Const colCommonIss As Long = 25  ' Y
    Const colCommonDom As Long = 26  ' Z
    Const colTC As Long = 1        ' A
    
    Const earlyDate As Date = #1/1/1900#
    Const lateDate As Date = #12/31/9999#
    
    ' Load data into arrays
    Dim effDates() As Date, expDates() As Date
    Dim directs() As String, deregs() As String, iss() As String, doms() As String
    Dim covs() As String, secs() As String, claims() As String
    ReDim effDates(2 To lastRow), expDates(2 To lastRow)
    ReDim directs(2 To lastRow), deregs(2 To lastRow), iss(2 To lastRow), doms(2 To lastRow)
    ReDim covs(2 To lastRow), secs(2 To lastRow), claims(2 To lastRow)
    
    Dim i As Long
    For i = 2 To lastRow
        effDates(i) = IIf(IsDate(ws.Cells(i, colEff).Value), ws.Cells(i, colEff).Value, earlyDate)
        expDates(i) = IIf(IsDate(ws.Cells(i, colExp).Value), ws.Cells(i, colExp).Value, lateDate)
        directs(i) = Trim(UCase(ws.Cells(i, colDirect).Value)) ' Normalize case and trim
        deregs(i) = UCase(Trim(ws.Cells(i, colDereg).Value))
        iss(i) = Trim(UCase(ws.Cells(i, colIss).Value)) ' Normalize case and trim
        doms(i) = Trim(UCase(ws.Cells(i, colDom).Value)) ' Normalize case and trim
        covs(i) = Trim(UCase(ws.Cells(i, colCov).Value)) ' Normalize case and trim
        secs(i) = Trim(UCase(ws.Cells(i, colSec).Value)) ' Normalize case and trim
        claims(i) = Trim(UCase(ws.Cells(i, colClaim).Value)) ' Normalize case and trim
    Next i
    
    ' Union-Find setup
    Dim parent() As Long
    ReDim parent(2 To lastRow)
    For i = 2 To lastRow
        parent(i) = i
    Next i
    
    ' Find and Union
    For i = 2 To lastRow - 1
        For j = i + 1 To lastRow
            Dim compareEff As Date: compareEff = IIf(effDates(i) > effDates(j), effDates(i), effDates(j))
            Dim minExp As Date: minExp = IIf(expDates(i) < expDates(j), expDates(i), expDates(j))
            If compareEff <= minExp Or (effDates(i) = earlyDate Or effDates(j) = earlyDate) Then
                If (directs(i) = directs(j) Or directs(i) = "" Or directs(j) = "") And _
                   (covs(i) = covs(j) Or covs(i) = "" Or covs(j) = "") And _
                   (secs(i) = secs(j) Or secs(i) = "" Or secs(j) = "") And _
                   (claims(i) = claims(j) Or claims(i) = "" Or claims(j) = "") Then
                    If deregs(i) = deregs(j) Or deregs(i) = "BOTH" Or deregs(j) = "BOTH" Then
                        Dim r1 As Long: r1 = i
                        While parent(r1) <> r1
                            r1 = parent(r1)
                        Wend
                        Dim r2 As Long: r2 = j
                        While parent(r2) <> r2
                            r2 = parent(r2)
                        Wend
                        If r1 <> r2 Then parent(r1) = r2
                    End If
                End If
            End If
        Next j
    Next i
    
    ' Path compression and collect groups
    Dim groups As Object
    Set groups = CreateObject("Scripting.Dictionary")
    For i = 2 To lastRow
        Dim root As Long: root = i
        While parent(root) <> root
            root = parent(root)
        Wend
        Dim p As Long: p = i
        While parent(p) <> root
            Dim nextP As Long: nextP = parent(p)
            parent(p) = root
            p = nextP
        Wend
        If Not groups.Exists(root) Then
            Set groups(root) = New Collection
        End If
        groups(root).Add i
    Next i
    
    ' Convert to collection of groups
    Dim groupList As New Collection
    For Each key In groups.Keys
        groupList.Add groups(key)
    Next key
    
    ' Sort groups by min row number
    Dim swapped As Boolean
    Do
        swapped = False
        For i = 1 To groupList.Count - 1
            Dim g1 As Collection: Set g1 = groupList(i)
            Dim g2 As Collection: Set g2 = groupList(i + 1)
            Dim min1 As Long: min1 = g1(1)
            Dim min2 As Long: min2 = g2(1)
            If min1 > min2 Then
                Dim temp As Collection
                Set temp = groupList(i)
                Set groupList(i) = groupList(i + 1)
                Set groupList(i + 1) = temp
                swapped = True
            End If
        Next i
    Loop While swapped
    
    ' Sort within each group by row number
    For Each g In groupList
        Do
            swapped = False
            For i = 1 To g.Count - 1
                If g(i) > g(i + 1) Then
                    Dim tmp As Long: tmp = g(i)
                    g(i) = g(i + 1)
                    g(i + 1) = tmp
                    swapped = True
                End If
            Next i
        Loop While swapped
    Next g
    
    ' Prepare new data array (copy entire rows)
    Dim maxCol As Long: maxCol = ws.UsedRange.Columns.Count
    Dim newData() As Variant
    ReDim newData(1 To lastRow - 1, 1 To maxCol)
    
    Dim newIdx As Long: newIdx = 1
    For Each g In groupList
        For Each oldRow In g
            Dim c As Long
            For c = 1 To maxCol
                newData(newIdx, c) = ws.Cells(oldRow, c).Value
            Next c
            newIdx = newIdx + 1
        Next oldRow
    Next g
    
    ' Clear old data
    ws.Rows("2:" & lastRow).ClearContents
    
    ' Paste new data
    ws.Range(ws.Cells(2, 1), ws.Cells(lastRow, maxCol)).Value = newData
    
    ' Process groups for commons, TC, and merging
    Application.DisplayAlerts = False
    Dim currRow As Long: currRow = 2
    For Each g In groupList
        Dim gSize As Long: gSize = g.Count
        Dim maxEff As Date: maxEff = earlyDate
        Dim hasEff As Boolean: hasEff = False
        For Each oldRow In g
            If effDates(oldRow) <> earlyDate Then
                If effDates(oldRow) > maxEff Then maxEff = effDates(oldRow)
                hasEff = True
            End If
        Next oldRow
        Dim commonDate As Variant
        If Not hasEff Then
            commonDate = ""
        Else
            commonDate = maxEff
        End If
        
        Dim issDict As Object: Set issDict = CreateObject("Scripting.Dictionary")
        For Each oldRow In g
            If iss(oldRow) <> "" Then issDict(iss(oldRow)) = 1
        Next oldRow
        Dim commonIss As String: commonIss = Join(issDict.Keys, ",")
        
        Dim domDict As Object: Set domDict = CreateObject("Scripting.Dictionary")
        For Each oldRow In g
            If doms(oldRow) <> "" Then domDict(doms(oldRow)) = 1
        Next oldRow
        Dim commonDom As String: commonDom = Join(domDict.Keys, ",")
        
        Dim groupStart As Long: groupStart = currRow
        Dim groupEnd As Long: groupEnd = currRow + gSize - 1
        Dim n As Long: n = 1
        For i = groupStart To groupEnd
            ws.Cells(i, colTC).Value = "TC_" & n
            ws.Cells(i, colCommonDate).Value = commonDate
            ws.Cells(i, colCommonIss).Value = commonIss
            ws.Cells(i, colCommonDom).Value = commonDom
            n = n + 1
        Next i
        
        If gSize > 1 Then
            ws.Range(ws.Cells(groupStart, colCommonDate), ws.Cells(groupEnd, colCommonDate)).Merge
            ws.Range(ws.Cells(groupStart, colCommonIss), ws.Cells(groupEnd, colCommonIss)).Merge
            ws.Range(ws.Cells(groupStart, colCommonDom), ws.Cells(groupEnd, colCommonDom)).Merge
        End If
        
        currRow = currRow + gSize
    Next g
    Application.DisplayAlerts = True
End Sub

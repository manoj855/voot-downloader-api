Option Explicit

Sub BuildTestCaseGroups_StrictMatch()
    Dim ws As Worksheet, logWs As Worksheet
    Set ws = ActiveSheet
    
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, "J").End(xlUp).Row
    If lastRow < 2 Then
        MsgBox "No data rows found.", vbExclamation
        Exit Sub
    End If
    
    ' Prepare log sheet
    On Error Resume Next
    Set logWs = ThisWorkbook.Sheets("Merge_Log")
    On Error GoTo 0
    If logWs Is Nothing Then
        Set logWs = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
        logWs.Name = "Merge_Log"
        logWs.Range("A1:E1").Value = Array("GroupID", "Row", "Note", "CommonIss", "Timestamp")
    Else
        logWs.Range("A2:E" & logWs.Rows.Count).ClearContents
    End If
    Dim logRow As Long: logRow = logWs.Cells(logWs.Rows.Count, "A").End(xlUp).Row + 1
    
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    ' --- Step 1: create groupIDs and initialize to 0 ---
    Dim groupID() As Long
    ReDim groupID(2 To lastRow)
    Dim i As Long, j As Long
    Dim nextGroup As Long: nextGroup = 1
    
    ' Read columns into arrays to speed up
    Dim effArr As Variant, expArr As Variant
    Dim directArr As Variant, deregArr As Variant
    Dim issueArr As Variant, domArr As Variant
    Dim covArr As Variant, sectArr As Variant, claimArr As Variant
    
    effArr = ws.Range("J2:J" & lastRow).Value2
    expArr = ws.Range("K2:K" & lastRow).Value2
    directArr = ws.Range("O2:O" & lastRow).Value2
    deregArr = ws.Range("P2:P" & lastRow).Value2
    issueArr = ws.Range("Q2:Q" & lastRow).Value2
    domArr = ws.Range("R2:R" & lastRow).Value2
    covArr = ws.Range("S2:S" & lastRow).Value2
    sectArr = ws.Range("T2:T" & lastRow).Value2
    claimArr = ws.Range("U2:U" & lastRow).Value2
    
    ' --- Step 2: Build groups (pairwise + transitive) using strict list intersection ---
    For i = 2 To lastRow
        If groupID(i) = 0 Then
            groupID(i) = nextGroup
            For j = i + 1 To lastRow
                If groupID(j) = 0 Then
                    If RowsMatch_Strict(i, j, effArr, expArr, directArr, deregArr, issueArr, domArr, covArr, sectArr, claimArr) Then
                        groupID(j) = groupID(i)
                    End If
                End If
            Next j
            ' transitive closure
            Dim changed As Boolean
            Do
                changed = False
                For j = 2 To lastRow
                    If groupID(j) = groupID(i) Then
                        Dim k As Long
                        For k = 2 To lastRow
                            If groupID(k) = 0 Then
                                If RowsMatch_Strict(j, k, effArr, expArr, directArr, deregArr, issueArr, domArr, covArr, sectArr, claimArr) Then
                                    groupID(k) = groupID(i)
                                    changed = True
                                End If
                            End If
                        Next k
                    End If
                Next j
            Loop While changed
            nextGroup = nextGroup + 1
        End If
    Next i
    
    ' --- Step 3: Reorder rows by groupID (stable within group) ---
    Dim orderArr() As Long
    ReDim orderArr(2 To lastRow)
    Dim idx As Long: idx = 2
    Dim g As Long
    For g = 1 To nextGroup - 1
        For i = 2 To lastRow
            If groupID(i) = g Then
                orderArr(idx) = i
                idx = idx + 1
            End If
        Next i
    Next g
    ' fill any remaining
    For i = 2 To lastRow
        If orderArr(i) = 0 Then orderArr(i) = i
    Next i
    
    Dim tmp As Worksheet
    Set tmp = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
    tmp.Name = "TMP_Reorder_" & Format(Now, "hhmmss")
    ws.Rows(1).Copy tmp.Rows(1)
    Dim destRow As Long: destRow = 2
    For i = 2 To lastRow
        ws.Rows(orderArr(i)).Copy tmp.Rows(destRow)
        tmp.Cells(destRow, "Z").Value = groupID(orderArr(i)) ' keep group id in Z temporarily for verification
        logWs.Cells(logRow, 1).Value = groupID(orderArr(i))
        logWs.Cells(logRow, 2).Value = orderArr(i)
        logWs.Cells(logRow, 3).Value = "Moved to " & destRow
        logWs.Cells(logRow, 5).Value = Now
        logRow = logRow + 1
        destRow = destRow + 1
    Next i
    
    ' Replace original with temp copy
    ws.Rows("1:" & lastRow).ClearContents
    tmp.Rows("1:" & destRow - 1).Copy ws.Rows(1)
    Application.DisplayAlerts = False
    tmp.Delete
    Application.DisplayAlerts = True
    
    ' --- Step 4: For each contiguous group compute common fields and write TC & X/Y/Z and merge A-C ---
    lastRow = ws.Cells(ws.Rows.Count, "J").End(xlUp).Row
    Dim rowPtr As Long: rowPtr = 2
    Dim groupCounter As Long: groupCounter = 1
    
    Do While rowPtr <= lastRow
        ' find group block: rows have same temp group id in column Z
        Dim thisGroupID As Variant
        thisGroupID = ws.Cells(rowPtr, "Z").Value
        Dim startRow As Long: startRow = rowPtr
        Dim endRow As Long: endRow = rowPtr
        Dim rr As Long
        For rr = rowPtr + 1 To lastRow
            If ws.Cells(rr, "Z").Value = thisGroupID Then
                endRow = rr
            Else
                Exit For
            End If
        Next rr
        
        ' compute intersection for issuing and domicile using strict intersection
        Dim commonIss As String: commonIss = ""
        Dim commonDom As String: commonDom = ""
        Dim r As Long
        For r = startRow To endRow
            If Trim(ws.Cells(r, "Q").Value) <> "" Then
                If commonIss = "" Then
                    commonIss = ws.Cells(r, "Q").Value
                Else
                    commonIss = IntersectCommaLists_Strict(commonIss, ws.Cells(r, "Q").Value)
                End If
            End If
            If Trim(ws.Cells(r, "R").Value) <> "" Then
                If commonDom = "" Then
                    commonDom = ws.Cells(r, "R").Value
                Else
                    commonDom = IntersectCommaLists_Strict(commonDom, ws.Cells(r, "R").Value)
                End If
            End If
        Next r
        
        ' compute common date start per earlier rules (max of eff dates present), validate with expiries if present
        Dim haveStart As Boolean: haveStart = False
        Dim maxEff As Double: maxEff = -1E+99
        Dim haveExpiry As Boolean: haveExpiry = False
        Dim minExp As Double: minExp = 1E+99
        For r = startRow To endRow
            If IsDate(ws.Cells(r, "J").Value) Then
                haveStart = True
                If CDbl(CDate(ws.Cells(r, "J").Value)) > maxEff Then maxEff = CDbl(CDate(ws.Cells(r, "J").Value))
            End If
            If IsDate(ws.Cells(r, "K").Value) Then
                haveExpiry = True
                If CDbl(CDate(ws.Cells(r, "K").Value)) < minExp Then minExp = CDbl(CDate(ws.Cells(r, "K").Value))
            End If
        Next r
        
        Dim finalCommonDate As Variant: finalCommonDate = ""
        If haveStart Then
            If Not haveExpiry Then
                finalCommonDate = CDate(maxEff)
            Else
                If maxEff <= minExp Then finalCommonDate = CDate(maxEff) Else finalCommonDate = ""
            End If
        Else
            finalCommonDate = "" ' applies to all
        End If
        
        ' write TC label, write X/Y/Z on startRow, merge A:B:C across block
        Dim tcLabel As String: tcLabel = "TC_" & groupCounter
        ws.Range(ws.Cells(startRow, "A"), ws.Cells(endRow, "A")).Merge
        ws.Range(ws.Cells(startRow, "B"), ws.Cells(endRow, "B")).Merge
        ws.Range(ws.Cells(startRow, "C"), ws.Cells(endRow, "C")).Merge
        ws.Cells(startRow, "A").Value = tcLabel
        If finalCommonDate <> "" Then ws.Cells(startRow, "X").Value = finalCommonDate
        ws.Cells(startRow, "Y").Value = commonIss
        ws.Cells(startRow, "Z").Value = commonDom
        
        ' log the commonIss for verification
        logWs.Cells(logRow, 1).Value = groupCounter
        logWs.Cells(logRow, 2).Value = startRow
        logWs.Cells(logRow, 3).Value = "Common Iss/Dom for group"
        logWs.Cells(logRow, 4).Value = commonIss & " | " & commonDom
        logWs.Cells(logRow, 5).Value = Now
        logRow = logRow + 1
        
        groupCounter = groupCounter + 1
        rowPtr = endRow + 1
    Loop
    
    ' clear the temp group id column Z we used
    ws.Range("Z2:Z" & lastRow).ClearContents
    
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    
    MsgBox "Grouping & merging completed with strict token matching. Check Merge_Log for details.", vbInformation
End Sub

' -----------------------
' Strict RowsMatch using arrays (same signature as earlier RowsMatch but uses strict list intersection)
Function RowsMatch_Strict(iRow As Long, jRow As Long, _
                   effArr As Variant, expArr As Variant, _
                   directArr As Variant, deregArr As Variant, _
                   issueArr As Variant, domArr As Variant, _
                   covArr As Variant, sectArr As Variant, claimArr As Variant) As Boolean
    
    Dim iIdx As Long, jIdx As Long
    iIdx = iRow - 1
    jIdx = jRow - 1
    RowsMatch_Strict = False
    
    Dim eff1 As Variant, eff2 As Variant
    eff1 = effArr(iIdx, 1)
    eff2 = effArr(jIdx, 1)
    
    Dim exp1 As Variant, exp2 As Variant
    exp1 = expArr(iIdx, 1)
    exp2 = expArr(jIdx, 1)
    
    Dim direct1 As String, direct2 As String
    direct1 = LCase(Trim(CStr(directArr(iIdx, 1))))
    direct2 = LCase(Trim(CStr(directArr(jIdx, 1))))
    
    Dim dereg1 As String, dereg2 As String
    dereg1 = LCase(Trim(CStr(deregArr(iIdx, 1))))
    dereg2 = LCase(Trim(CStr(deregArr(jIdx, 1))))
    
    Dim issue1 As String, issue2 As String
    issue1 = Trim(CStr(issueArr(iIdx, 1)))
    issue2 = Trim(CStr(issueArr(jIdx, 1)))
    
    Dim dom1 As String, dom2 As String
    dom1 = Trim(CStr(domArr(iIdx, 1)))
    dom2 = Trim(CStr(domArr(jIdx, 1)))
    
    Dim cov1 As String, cov2 As String, sect1 As String, sect2 As String, claim1 As String, claim2 As String
    cov1 = LCase(Trim(CStr(covArr(iIdx, 1))))
    cov2 = LCase(Trim(CStr(covArr(jIdx, 1))))
    sect1 = LCase(Trim(CStr(sectArr(iIdx, 1))))
    sect2 = LCase(Trim(CStr(sectArr(jIdx, 1))))
    claim1 = LCase(Trim(CStr(claimArr(iIdx, 1))))
    claim2 = LCase(Trim(CStr(claimArr(jIdx, 1))))
    
    ' Date compatibility (blank = applies to all)
    Dim dateCompatible As Boolean: dateCompatible = True
    If IsDate(eff1) And IsDate(exp1) And IsDate(eff2) And IsDate(exp2) Then
        If Not (CDate(eff2) <= CDate(exp1) And CDate(exp2) >= CDate(eff1)) Then dateCompatible = False
    End If
    If Not dateCompatible Then Exit Function
    
    ' Direct if both present must match
    If direct1 <> "" And direct2 <> "" Then
        If direct1 <> direct2 Then Exit Function
    End If
    
    ' Dereg: Both compatible with Y or N
    If dereg1 <> "" And dereg2 <> "" Then
        If (dereg1 <> dereg2) And (dereg1 <> "both") And (dereg2 <> "both") Then Exit Function
    End If
    
    ' Cov/sect/claim if both present must overlap as substring (looser)
    If cov1 <> "" And cov2 <> "" Then
        If InStr(1, cov1, cov2, vbTextCompare) = 0 And InStr(1, cov2, cov1, vbTextCompare) = 0 Then Exit Function
    End If
    If sect1 <> "" And sect2 <> "" Then
        If InStr(1, sect1, sect2, vbTextCompare) = 0 And InStr(1, sect2, sect1, vbTextCompare) = 0 Then Exit Function
    End If
    If claim1 <> "" And claim2 <> "" Then
        If InStr(1, claim1, claim2, vbTextCompare) = 0 And InStr(1, claim2, claim1, vbTextCompare) = 0 Then Exit Function
    End If
    
    ' Issuing company and domicile must have at least one exact token match (strict)
    If Not CommaListsIntersect_Strict(issue1, issue2) Then Exit Function
    If Not CommaListsIntersect_Strict(dom1, dom2) Then Exit Function
    
    RowsMatch_Strict = True
End Function

' Strictly check intersection: exact token equality (case-insensitive)
Function CommaListsIntersect_Strict(a As String, b As String) As Boolean
    Dim arrA() As String, arrB() As String
    If Trim(a) = "" Or Trim(b) = "" Then
        CommaListsIntersect_Strict = False
        Exit Function
    End If
    arrA = Split(a, ",")
    arrB = Split(b, ",")
    Dim x As Long, y As Long
    For x = LBound(arrA) To UBound(arrA)
        For y = LBound(arrB) To UBound(arrB)
            If LCase(Trim(arrA(x))) <> "" And LCase(Trim(arrB(y))) <> "" Then
                If LCase(Trim(arrA(x))) = LCase(Trim(arrB(y))) Then
                    CommaListsIntersect_Strict = True
                    Exit Function
                End If
            End If
        Next y
    Next x
    CommaListsIntersect_Strict = False
End Function

' Strict intersection that returns tokens from first argument that exactly appear in second (original casing from first)
Function IntersectCommaLists_Strict(a As String, b As String) As String
    Dim arrA() As String, arrB() As String
    If Trim(a) = "" Or Trim(b) = "" Then
        IntersectCommaLists_Strict = ""
        Exit Function
    End If
    arrA = Split(a, ",")
    arrB = Split(b, ",")
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    Dim i As Long, itemB As String
    For i = LBound(arrB) To UBound(arrB)
        itemB = LCase(Trim(arrB(i)))
        If itemB <> "" Then dict(itemB) = 1
    Next i
    Dim out As String: out = ""
    Dim itemA As String
    For i = LBound(arrA) To UBound(arrA)
        itemA = Trim(arrA(i))
        If itemA <> "" Then
            If dict.Exists(LCase(itemA)) Then
                If out = "" Then out = itemA Else out = out & ", " & itemA
            End If
        End If
    Next i
    IntersectCommaLists_Strict = out
End Function
